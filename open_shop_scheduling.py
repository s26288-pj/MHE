import itertools
import random
import time
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches


def generate_random_solution(num_jobs, num_machines):
    """ Generate random solution for Open Shop Scheduling.

    :param num_jobs: number of jobs to be distributed among machines
    :param num_machines: number of devices that will be responsible for finishing jobs
    """
    return [(job, machine) for job in range(num_jobs) for machine in range(num_machines)]


def generate_all_solutions(num_jobs, num_machines):
    """ Generate all possible solutions for Open Shop Scheduling.

    :param num_jobs: number of jobs to be distributed among machines
    :param num_machines: number of machines used for Open Shop Scheduling
    """
    jobs_machines = [(job, machine) for job in range(num_jobs) for machine in range(num_machines)]
    return list(itertools.permutations(jobs_machines))


def generate_neighbours(solution):
    """ Generate neighbours randomly. Neighbour is almost an identical copy of solution table, but with 2 swapped values.

    :param solution: current solution generated by generate_random_solution
    """
    a, b = random.sample(range(len(solution)), 2)
    neighbour = solution[:] # ta linia tworzy miękką kopię tablicy solution
    neighbour[a], neighbour[b] = neighbour[b], neighbour[a]
    return neighbour


def calculate_total_time(schedule, processing_times, num_jobs, num_machines):
    """ Sums up total time in current solution. Total time is equal to the longest job execution from all the devices.
    Considers machine and job availability!

    :param schedule: current solution
    :param processing_times: table of processing times of the jobs for each machine
    :param num_jobs: number of jobs that is distributed among devices
    :param num_machines: number of machines used for Open Shop Scheduling
    """
    # Generacja nowej tablicy o wielkości num_machines wypełnionej zerami dla czasu maszyny i czasu pracy
    machine_times = np.zeros(num_machines)
    job_times = np.zeros(num_jobs)
    # Znajdowanie maksymalnego czasu wykonania wszystkich prac przez maszyny
    for job, machine in schedule:
        start_time = max(machine_times[machine], job_times[job])
        job_times[job] = start_time + processing_times[job, machine]
        machine_times[machine] = job_times[job]
    return max(job_times)


def display_schedule(schedule, processing_times, num_jobs, num_machines):
    """ Displays graphs that help compairing different solutions.

    :param schedule: current solution
    :param processing_times: table of processing times of the jobs for each machine
    :param num_jobs: number of jobs that is distributed among devices
    :param num_machines: number of machines used for Open Shop Scheduling
    """
    fig, ax = plt.subplots(figsize=(10, num_machines))
    colors = plt.cm.get_cmap('tab10', num_jobs)
    machine_times = np.zeros(num_machines)
    job_times = np.zeros(num_jobs)
    for job, machine in schedule:
        start_time = max(machine_times[machine], job_times[job])
        duration = processing_times[job, machine]
        ax.add_patch(patches.Rectangle((start_time, machine), duration, 0.8, color=colors(job)))
        job_times[job] = start_time + duration
        machine_times[machine] = job_times[job]
    plt.xlabel('Time')
    plt.ylabel('Machine')
    plt.title('Open-shop Scheduling')
    plt.yticks(range(num_machines), [f'Machine {i}' for i in range(num_machines)])
    plt.show()


def hill_climbing(processing_times, num_jobs, num_machines, iterations=1000, show_plots=True):
    """ Hill Climbing algorithm function.

    :param processing_times: table of processing times of the jobs for each machine
    :param num_jobs: number of jobs that is distributed among devices
    :param num_machines: number of machines used for Open Shop Scheduling
    :param iterations: number of iterations
    :param show_plots: boolean that is responsible for turning on/off generating of the graphs
    """
    current_solution = generate_random_solution(num_jobs, num_machines)
    current_time = calculate_total_time(current_solution, processing_times, num_jobs, num_machines)
    total_time = [current_time]
    start_time = time.time()
    for _ in range(iterations):
        neighbor = generate_neighbours(current_solution)
        neighbor_time = calculate_total_time(neighbor, processing_times, num_jobs, num_machines)
        if neighbor_time < current_time:
            current_solution = neighbor
            current_time = neighbor_time
        total_time.append(current_time)
        if show_plots:
            display_schedule(current_solution, processing_times, num_jobs, num_machines)
            plt.pause(0.1)
    end_time = time.time()
    if show_plots:
        plt.ioff()
        plt.show()
    print(f"Execution time: {end_time - start_time:.4f} seconds")
    print(f"Final total time: {current_time:.4f}")
    return current_solution, current_time, total_time


def full_search(processing_times, num_jobs, num_machines, sample_size=None, show_plots=True):
    """ Full Search algorithm function.

    :param processing_times: table of processing times of the jobs for each machine
    :param num_jobs: number of jobs that is distributed among devices
    :param num_machines: number of machines used for Open Shop Scheduling
    :param sample_size: number of maximum samples to be calculated by the alghoritm
    :param show_plots: boolean that is responsible for turning on/off generating of the graphs
    """
    best_solution = None
    best_time = float('inf')

    all_solutions = generate_all_solutions(num_jobs, num_machines)
    if sample_size:
        all_solutions = all_solutions[:sample_size]

    total_time = []
    start_time = time.time()

    for idx, solution in enumerate(all_solutions):
        schedule = [(job, solution[job]) for job in range(num_jobs)]
        total_time = calculate_total_time(schedule, processing_times, num_jobs, num_machines)

        if total_time < best_time:
            best_time = total_time
            best_solution = schedule

        if show_plots:  # Show plot every 100 permutations
            display_schedule(best_solution, processing_times, num_jobs, num_machines)
            plt.pause(0.1)

    end_time = time.time()

    if show_plots:
        plt.ioff()
        plt.show()

    print(f"Execution time: {end_time - start_time:.4f} seconds")
    print(f"Final total time: {best_time:.4f}")

    return best_solution, best_time, total_time


def tabu_search(initial_solution, processing_times, num_jobs, num_machines, tabu_size=10, max_iterations=1000, show_plots=True):
    """ Tabu Search algorithm function.

    :param initial_solution: current solution
    :param processing_times: table of processing times of the jobs for each machine
    :param num_jobs: number of jobs that is distributed among devices
    :param num_machines: number of machines used for Open Shop Scheduling
    :param tabu_size: size of elements that will be unavailable for re-calculations
    :param max_iterations: number of maximum iterations allowed by algorithm
    :param show_plots: boolean that is responsible for turning on/off generating of the graphs
    """
    current_solution = initial_solution[:]
    current_time = calculate_total_time(current_solution, processing_times, num_jobs, num_machines)
    best_solution = current_solution[:]
    best_time = current_time

    tabu_list = []

    total_time = [current_time]
    start_time = time.time()

    for iter in range(max_iterations):
        neighbor = generate_neighbours(current_solution)
        neighbor_time = calculate_total_time(neighbor, processing_times, num_jobs, num_machines)

        # Check if the neighbor is not tabu or improves the current best solution
        if neighbor_time < current_time and neighbor not in tabu_list:
            current_solution = neighbor
            current_time = neighbor_time

            if current_time < best_time:
                best_solution = current_solution
                best_time = current_time

            # Add the current solution to the tabu list
            tabu_list.append(current_solution)
            if len(tabu_list) > tabu_size:
                tabu_list.pop(0)  # Remove the oldest solution if tabu list exceeds its size

        total_time.append(current_time)

        if show_plots:
            display_schedule(current_solution, processing_times, num_jobs, num_machines)
            plt.pause(0.1)

    end_time = time.time()

    if show_plots:
        plt.ioff()
        plt.show()

    print(f"Execution time: {end_time - start_time:.4f} seconds")
    print(f"Final total time: {best_time:.4f}")

    return best_solution, best_time, total_time


def generate_jobs(num_jobs, num_machines):
    """ Generates jobs with random execution times for each machine.

    :param num_jobs: number of jobs that is distributed among devices
    :param num_machines: number of machines used for Open Shop Scheduling
    """
    return np.random.randint(1, 100, (num_jobs, num_machines))


def compare_algorithms(num_jobs, num_machines, iterations, sample_size, tabu_size, show_plots):
    """ Compare the performance of Hill Climbing, Tabu Search, and Full Search algorithms.

    :param num_jobs: number of jobs that is distributed among devices
    :param num_machines: number of machines used for Open Shop Scheduling
    :param iterations: number of iterations for Hill Climbing and Tabu Search
    :param sample_size: number of permutations to consider for Full Search
    :param tabu_size: size of tabu list for Tabu Search
    :param show_plots: boolean that is responsible for turning on/off generating of the graphs
    """
    processing_times = generate_jobs(num_jobs, num_machines)

    print("Running Hill Climbing...")
    hc_solution, hc_time, hc_total_time = hill_climbing(processing_times, num_jobs, num_machines, iterations=iterations, show_plots=show_plots)

    print("Running Tabu Search...")
    initial_solution = generate_random_solution(num_jobs, num_machines)
    ts_solution, ts_time, ts_total_time = tabu_search(initial_solution, processing_times, num_jobs, num_machines, tabu_size=tabu_size, max_iterations=iterations, show_plots=show_plots)

    # Full Search is disabled due to long time of looking for all possible solutions
    # print("Running Full Search...")
    # fs_solution, fs_time, fs_total_time = full_search(processing_times, num_jobs, num_machines, sample_size=sample_size, show_plots=show_plots)

    # Plot results
    plt.plot(hc_total_time, label='Hill Climbing')
    plt.plot(ts_total_time, label='Tabu Search')
    plt.plot(fs_total_time, label='Full Search')
    plt.xlabel('Iteration')
    plt.ylabel('Total Time')
    plt.legend()
    plt.title('Algorithm Comparison')
    plt.show()

    # Print results
    print(f"Hill Climbing - Best Time: {hc_time:.4f} - Execution Time: {iterations} iterations")
    print(f"Tabu Search - Best Time: {ts_time:.4f} - Execution Time: {iterations} iterations")
    print(f"Full Search - Best Time: {fs_time:.4f} - Execution Time: {len(fs_total_time)} iterations")


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='Algorithm Comparison for Open-shop Scheduling')
    parser.add_argument('--jobs', type=int, default=10, help='Number of jobs')
    parser.add_argument('--machines', type=int, default=5, help='Number of machines')
    parser.add_argument('--iterations', type=int, default=1000, help='Number of iterations for Hill Climbing and Tabu Search')
    parser.add_argument('--sample_size', type=int, default=None, help='Number of permutations to consider for Full Search')
    parser.add_argument('--tabu_size', type=int, default=10, help='Size of tabu list for Tabu Search')
    parser.add_argument('--show_plots', action="store_true", help='Show plots during optimization')

    args = parser.parse_args()

    compare_algorithms(args.jobs, args.machines, args.iterations, args.sample_size, args.tabu_size, args.show_plots)
